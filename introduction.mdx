---
title: 'Introduction'
---

**Chronologue** is a memory-grounded planning system that integrates language models with calendar data to support personalized scheduling, reflection, and schedule-aware response and suggestions. Agents reason over structured event timelines and assist users through a familiar calendar interface. In turn, users can schedule and steer agent behavior by prompting their calendar to organize scheduled activities. 

<Info>
To get started, head to the [Quickstart Guide](/quickstart) or explore [Datasets](/examples/datasets).
</Info>

By connecting language models to calendar systems, Chronologue enables agents to:

- **Generate** calendar events from natural language memory traces (e.g., goals, reflections, observations).
- **Ground** responses and plans in real-world schedules, time constraints, and commitments.
- **Update** calendars with new structured events based on conversation context.
- **Retrieve** time-based context to improve coherence, relevance, and coordination in agent outputs.

This **bidirectional loop** ensures that both humans and agents can coordinate over time with transparency and adaptability.


<img height="200" src="/path/image.jpg" />

---

### Table of Contents

- **1. Introduction**

- **2. Core Concepts**
  - Memory Traces  
  - Calendar Integration  
  - Language Model Scheduling  
  - Editable and Promptable Interface  
  - Steerable Agents  

- **3. User Workflows**
  - Reviewing and editing past events  
  - Scheduling with memory context  
  - Weekly summaries and follow-up generation  
  - Handling missed or incomplete tasks  
  - Syncing with Google Calendar or Apple Calendar  

- **4. Agent Architecture**
  - Prompt and tool calling 
  - Event schema and trace conversion  
  - Planning and execution cycle (MCP protocol)  
  - User approval and edit layer  

- **5. System Integration**
  - `.ics` file generation and import/export  
  - Google Calendar API setup and sync  
  - iCalendar compatibility  
  - FastAPI endpoints 

- **6. Research Questions**
  - Duration estimation  
  - Tempo tokens and embeddings 
  - Memory summarization and ranking  
  - Feedback-based personalization  

- **7. Quickstart Guide**
  - Installation  
  - API keys and environment setup  
  - Running the Streamlit app  
  - Syncing your first memory trace  

---

## Core Concepts

**Memory Traces**

Structured JSON records of events -- such as goals, meetings, reflections, and tasks -- used as the foundation for grounding model reasoning and informing calendar updates. 

**Calendar Integration**

Memory traces are translated into `.ics` files, enabling full synchronization with tools like Google Calendar and Apple iCalendar. 

**Language Model Scheduling**

Chronologue uses model APIs (ie. function calling) to interpret user prompts and generate structured actions -- adding, editing, deleting, summarizing, and filtering events. 

**Editable and Promptable Interface**

Users can interact through a table-based UI, chat interface, or calendar interface to make memory data: 

- **Editable** ‚Äî Update, remove, or annotate memory traces (e.g., conversation history, scheduled events, reflections).
    
- **Promptable** ‚Äî Ask questions or issue commands (e.g., ‚ÄúWhat did I work on last Friday?‚Äù or ‚ÄúWhat should I focus on this Friday?‚Äù), with responses grounded in past calendar data.

- **Steerable Agents**  

Chronologue enables agents that act on behalf of the user, grounded in structured memory and calendar context. The goal is to give users control over agentic behavior in time‚Äîsuch as scheduling deliveries, appointments, reminders, or focus blocks.

Users maintain control through:

- **Approval and editing** of any agent-generated event before it‚Äôs added to the calendar.
    
- **Review of all actions** in a familiar, transparent calendar interface.
    
- **Direct prompting** of agents to take specific actions (e.g., ‚ÄúPlan my next study session,‚Äù ‚ÄúReschedule missed tasks from last week‚Äù).
    
- **Orchestration over time** by embedding memory, feedback, and scheduling preferences into the planning workflow.
    
Chronologue prioritizes autonomy: agents respond to user instruction ‚Äî users define the time, place, and action. 

---

## User Workflows 

**Review and Reflect**

View, filter, and annotate past memory traces and calendar events.

Example: ‚ÄúWhat were my goals last week?‚Äù

**Plan and Schedule**

Use natural language to generate new events or plans.

Example: ‚ÄúSchedule a 45-minute workout on Friday morning.‚Äù

**Catch Up and Reschedule**

Identify incomplete tasks and reschedule them with model support.

Example: ‚ÄúWhat did I miss this week? Reschedule to next open slot.‚Äù

**Summarize and Follow Up**

Generate weekly summaries and follow-up suggestions based on past actions.

Example: ‚ÄúSummarize my progress this week.‚Äù

**Calendar Sync and Integration**

Import/export .ics files, sync with Google Calendar or iCal.

Example: Automatically push new memory-derived events into your calendar app.


üìò Cookbook of Example Prompts
Hands-on Jupyter notebook demonstrating a sample workflow and data format (event generation, rescheduling, summarization, etc.).

üñ• Streamlit App Demo
Launch the interactive interface to explore your memory traces and test agent behaviors in real time.


## Agent Architecture

Chronologue agents translate user intent into structured calendar actions using prompt-based reasoning, function calling, and memory-grounded context.

**Prompt and Tool Calling**

Chronologue uses language models (e.g., OpenAI with function calling) to interpret user prompts and generate structured commands such as add_event, edit_event, or reschedule_event. These tools enforce a controlled API for agent behavior, ensuring traceable and editable outputs.

**Event Schema and Trace Conversion**

User inputs and model outputs are structured as memory traces in a standardized JSON format. These traces include fields like:

- `type` (e.g., `calendar_event`, `goal`, `reflection`)

- `timestamp`, `title`, `content`, `duration`, `uid`

- `linked_event_uid` for event relationships

This schema enables trace-to-event conversion for `.ics` generation and calendar syncing.

**Planning and Execution Cycle (MCP Protocol)**

Chronologue implements the Model Context Protocol (MCP) to structure the flow of agent behavior:

`/context` ‚Äì Retrieves relevant memory traces

`/plan` ‚Äì Uses LLM to generate structured planning output

`/act` ‚Äì Applies validated changes to memory or calendar state

This loop enables transparent, inspectable agent actions over time.

**User Approval and Edit Layer**

All agent-generated actions are staged for review before execution. Users can:

- Inspect and edit proposed changes in the `calendar/table` view

- Accept, modify, or reject suggestions

- Maintain full oversight over automated scheduling behavior

